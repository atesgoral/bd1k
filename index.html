<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Boulder Dash</title>
    <link rel="stylesheet" href="style.css">
  </head>
  <body id="body">
    <div id="error"></div>
    <canvas id="canvas" width="1024" height="640"></canvas>
    <div id="bytes"></div>
    <textarea id="minified" rows="12"></textarea>
    <script>
      const a = canvas;
      const b = body;
      const c = a.getContext('2d');
      const d = document;

      a.width = a.offsetWidth;
      a.height = a.offsetHeight;
    </script>
    <script id="source" type="text/annotated">
// predefined global variables:
// ctx - canvas 2D context

// piggybacks (on predefined global variables):
// processed - tile process markers - piggybacked on canvas element
// keyDown - key down flags - piggybacked on body element
// playerVectors - player vectors - piggybacked on canvas 2D context

// tiles
(tiles = new Image).src = 'data:;base64,iVBORw0KGgoAAAANSUhEUgAAACgAAAAQAgMAAAAZudU+AAAADFBMVEUAAABfX1/QQAD///+L6qNxAAAAi0lEQVQI12NgYAgN5VDiPwBkgJgLmsw3sAgAmY6Oaipv/7AGAJmBgYsWVe4XdAEyCwu7usLqgUyQWokZqemsAWBmpldUPKMDmNm1JBQmqpXlGiZ8BMyctCQwjbcAbO6MJNdQ5gNgc6XUAkPB2goLOzpCQrgfQNywSDSEQwHM7FRgmQBlKnQwOtjYAAC3bipFr0J0MQAAAABJRU5ErkJggg';

// turns off image smoothing to get crispy and chunky pixels
disableImageSmoothing = prefix =>
  ctx[prefix + 'mageSmoothingEnabled'] = 0;

// processed frame counter to prevent reprocessing a moved tile
processCount = // initialize to 0
  disableImageSmoothing('i'), // Chrome
  disableImageSmoothing('mozI'); // Firefox

onkeydown = event =>
  playerVectors[
    keyDown[
      event = event.which // grab arrow key code (37: left, 38: up, 39: right, 40: down)
    ] = 1, // mark key as down
    event & 1 // vector index based on key (0: y vector, 1: x vector)
  ] = (event & 2) - 1; // set vector to -1 or 1 depending on key (y vector is inverted)

onkeyup = event =>
  keyDown[event = event.which] // if key was down
    ? playerVectors[event & 1] = // then set corresponding vector to 0
        keyDown[event] = 0 // and mark key as not down
    : 0;

mapHeight = 20;
mapWidthOrTileSize = 32;

mapArea = mapHeight * mapWidthOrTileSize;

exit = mapArea - mapWidthOrTileSize - 1; // inside bottom right wall

map = [
  levelTransition = 1 // level transition counter (0: run game, >0: level transition)
];

seed = 5; // PRNG (pseudo-random number generator) seed

// randomly returns true/false, with 80% preference for true
preferably = _ => (
  (seed += seed * seed | 5) // PRNG
  % // modulus to contain random values within range
  mapArea // just a large value we already have
) / mapArea < .8;

// calls given callback on every map tile
iterate = callback => {
  for (j = 0; j < mapArea; j++)
    callback(j, j % mapWidthOrTileSize, j / mapWidthOrTileSize | 0)
};

// starts a level
startLevel = _ => {
  // initialize map
  iterate(
    (j, x, y) =>
      map[j] =
        x * y // if not top or left edge
        && x < mapWidthOrTileSize - 1 // and not right edge
        && y < mapHeight - 1 // and not bottom edge
          // then pick a random non-wall tile
          ? preferably()
            ? preferably()
              ? 2 // dirt - 80% * 20% = 16%
              : 3 // boulder - 20% * 20% = 5%
            : 0 // empty space - 20%
          // else put a wall
          : 1 // wall
  );

  // place player on top left
  map[mapWidthOrTileSize + 1] = 4; // player

  // place exit
  map[exit] = 0 // empty space
};

setInterval(_ => {
  // render map
  iterate((j, x, y) =>
    ctx.drawImage(
      tiles, // source image
      // source tile x
      levelTransition // if level transition in progress
      && (x + y) % mapHeight <= mapHeight - levelTransition // diagonal blinds
        ? 8 // wall tile
        : map[j] * 8, // use tile from map
      0, // source tile y
      8, // source tile width
      16, // source tile height
      x * mapWidthOrTileSize, // destination tile x
      y * mapWidthOrTileSize, // destination tile y
      mapWidthOrTileSize, // destination tile width
      mapWidthOrTileSize // destination tile height
    )
  );

  // sets a tile on the map
  move = _ =>
    map[
      map[j] = 0,
      processed[k] = processCount, // mark tile as processed
      k // tile index
    ] = t; // new tile value

  levelTransition // if in the process of level transition
    ? --levelTransition || // then decrement counter
      startLevel() // start next level if counter has reached 0
    : map[exit] // else if exit is occupied (by player)
      ? levelTransition = mapHeight // then start level transition
      : iterate( // else process map
        j =>
          processed[j] != processCount && // tile hasn't been already processed in this frame (might have been moved into this position)
          (t = map[j]) > 2 && // if tile boulder or player
          { // tile handlers
            3: _ => // boulder
              !map[k = j + mapWidthOrTileSize] // if beneath boulder is empty
                ? move() // move boulder down
                : map[j + mapWidthOrTileSize] == 3 // else if resting on another boulder
                  ? map[k = j - 1] + map[j + mapWidthOrTileSize - 1] < 1 // else if can slide left
                    ? move() // move boulder left
                    : map[k = j + 1] + map[j + mapWidthOrTileSize + 1] < 1 // else if can slide right
                      ? move() // move boulder right
                      : 0
                  : 0,
            4: _ => // player
              playerVectors[0] & ~map[k = j + playerVectors[0] * -mapWidthOrTileSize] & 1
              || playerVectors[1] & ~map[k = j + playerVectors[1]] & 1
                ? move() // move player
                : 0
          }[t](), // invoke tile handler
        processCount++ // increment process count
      )
}, 99) // render and process every 99 ms
    </script>
    <script>
      const src = source.innerHTML;
      // Poor man's minifier
      const min = src
        .replace(/\s+\/\/.+$/gm, '') // Trim line comments
        .replace(/[\s\n]+(?!\w)/gm, '') // Trim all whitespace that are not followed by word character
        .replace(/(\W)[\s\n]+/gm, '$1') // Trim all whitespace that follow a non-word character
        .replace(/(\w+)/gm, (s, name) => { // Shorten variables
          return {
            iterate: 'i',
            preferably: 'r',
            seed: 'q',
            mapHeight: 'h',
            mapWidthOrTileSize: 'w',
            mapArea: 'A',
            exit: 'e',
            levelTransition: 'o',
            tiles: 'p',
            map: 'm',
            move: 'v',
            startLevel: '$',
            disableImageSmoothing: 'l',
            processCount: 'f',
            // arguments
            prefix: 'p',
            event: 'e',
            callback: 'f',
            // predefined globals
            ctx: 'c',
            // piggybacks
            processed: 'a',
            keyDown: 'b',
            playerVectors: 'c'
          }[name] || name;
        });

      bytes.innerHTML = min.length;
      minified.value = min;

      try {
        eval(min);
      } catch (e) {
        error.innerHTML = e.message;
      }
    </script>
  </body>
</html>
