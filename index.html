<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Boulder Dash - js1k 2017</title>
    <link rel="stylesheet" href="style.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.6.0/themes/prism-okaidia.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.6.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.6.0/components/prism-javascript.min.js"></script>
    <script src="main.js"></script>
  </head>
  <body id="body">
    <header>
      <h1>Boulder Dash - js1k 2017</h1>
      <p>by <a href="http://magnetiq.com">Ates Goral</a></p>
      <p>Use arrow keys to reach the exit on the bottom right. Don't get trapped among boulders. Click on canvas to capture keyboard events.</p>
    </header>
    <main>
      <p id="error"></p>
      <p><canvas id="canvas" width="1024" height="640" tabindex="0"></canvas></p>
      <p id="bytes"></p>
      <h2>Minified</h2>
      <pre><code id="minified" class="language-javascript"></code></pre>
      <h2>Annotated</h2>
      <pre><code id="source" class="language-javascript"></code></pre>
    </main>
    <footer>
      &copy; 2017 <a href="http://magnetiq.com">Ates Goral</a>
    </footer>
    <script id="rawSrc" type="text/plain">
// predefined global variables:
// ctx - canvas 2D context

// piggybacks (on predefined global variables):
// processed - tile process markers - piggybacked on canvas element
// keyDown - key down flags - piggybacked on body element
// playerVectors - player vectors - piggybacked on canvas 2D context

// tiles
(tiles = new Image).src =
  // browsers are resilient to omitting the content type (image/png) and the trailing base-64 paddings (=)
  'data:;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAQAgMAAAAtwBQiAAAADFBMVEUAAABSUlKlKgD///8IGsOpAAAAr0lEQVQI12NgYAgN5VDiP8DAAMQgzoIm8w0sAuYbgBxHRzWVt39YA97+AXICAxctqtwv6FK5H8gpLOzqCqsXdAmrB+uRmJGazhqQmg7mZHpFxTM6RMWDOV1LQoEyoRAZrSzXMOEjrmFgzqQlgWm8BYFpYHtmJLmGMh9wDQXbI6UWGMroEDgVbE9HR0gI94MlMyBuWyQawqGgtQTM6VRgmcChwLEAzFHoYHSwsVm1CgB99zkKgltqtwAAAABJRU5ErkJggg';

// processed frame counter to prevent reprocessing a moved tile
processCount = // initialize to 0
  ctx.imageSmoothingEnabled = 0; // turn off image smoothing to get crispy and chunky pixels

onkeydown = event =>
  playerVectors[
    keyDown[
      event = event.which // grab arrow key code (37: left, 38: up, 39: right, 40: down)
    ] = 1, // mark key as down
    event & 1 // vector index based on key (0: y vector, 1: x vector)
  ] = (event & 2) - 1; // set vector to -1 or 1 depending on key (y vector is inverted)

onkeyup = event =>
  keyDown[event = event.which] // if key was down
    ? playerVectors[event & 1] = // then set corresponding vector to 0
        keyDown[event] = 0 // and mark key as not down
    : 0;

mapHeight = 20;
mapWidthOrTileSize = 32;

mapArea = mapHeight * mapWidthOrTileSize;

exit = mapArea - mapWidthOrTileSize - 1; // inside bottom right wall

map = [
  levelTransition = 1 // level transition counter (0: run game, >0: level transition)
];

seed = 5; // PRNG (pseudo-random number generator) seed

// randomly returns true/false, with 80% preference for true
preferably = _ => (
  (seed += seed * seed | 5) // PRNG
  % // modulus to contain random values within range
  mapArea // just a large value we already have
) / mapArea < .8;

// calls given callback on every map tile
iterate = callback => {
  for (j = 0; j < mapArea;)
    callback(j, j % mapWidthOrTileSize, j++ / mapWidthOrTileSize | 0)
};

// starts a level
startLevel = _ => {
  // initialize map
  iterate(
    (j, x, y) =>
      map[j] =
        x * y // if not top or left edge
        && x < mapWidthOrTileSize - 1 // and not right edge
        && y < mapHeight - 1 // and not bottom edge
          // then pick a random non-wall tile
          ? preferably()
            ? preferably()
              ? 2 // dirt - 80% * 20% = 16%
              : 3 // boulder - 20% * 20% = 5%
            : 0 // empty space - 20%
          // else put a wall
          : 1 // wall
  );

  // place player on top left
  map[mapWidthOrTileSize + 1] = 4; // player

  // place exit
  map[exit] = 0 // empty space
};

setInterval(_ => {
  // render map
  iterate((j, x, y) =>
    ctx.drawImage(
      tiles, // source image
      // source tile x
      levelTransition // if level transition in progress
      && (x + y) % mapHeight <= mapHeight - levelTransition // diagonal blinds
        ? 8 // wall tile
        : (map[j] & 7) * 8, // use tile from map (ignore bit 3)
      0, // source tile y
      8, // source tile width
      16, // source tile height
      x * mapWidthOrTileSize, // destination tile x
      y * mapWidthOrTileSize, // destination tile y
      mapWidthOrTileSize, // destination tile width
      mapWidthOrTileSize // destination tile height
    )
  );

  levelTransition // if in the process of level transition
    ? --levelTransition || // then decrement counter
      startLevel() // start next level if counter has reached 0
    : map[exit] // else if exit is occupied (by player)
      ? levelTransition = mapHeight // then start level transition
      : iterate( // else process map
        j =>
          processed[j] != processCount // tile hasn't been already processed in this frame (might have been moved into this position)
          && ((
            tile = map[j], // get tile
            map[j] = tile & 7 // reset bit 3
          ) + 1 & 6) == 4 // and if tile is a boulder or a player
          && { // then invoke tile handler (& 7 to ignore bit 3)
            3: _ => // boulder handler
              !map[dest = j + mapWidthOrTileSize] // if beneath the boulder is empty
                ? 1 // move boulder down
                : map[j + mapWidthOrTileSize] == 3 // else if resting on another boulder
                  ? map[dest = j - 1] + map[j + mapWidthOrTileSize - 1] < 1 // else if can slide left
                    ? 1 // move boulder left
                    : map[dest = j + 1] + map[j + mapWidthOrTileSize + 1] < 1 // else if can slide right
                      ? 1 // move boulder right
                      : 0
                  : map[j + mapWidthOrTileSize] == 4 // else if the player is beneath the boulder
                    && tile & 8 // and if the boulder is falling (bit 3 is set)
                    ? tile = (levelTransition = mapHeight, seed = 5) // crush player (turn into blodied boulder)
                    : 0,
            4: _ => // player handler
              playerVectors[0] & ~map[dest = j + playerVectors[0] * -mapWidthOrTileSize] & 1 // if the y vector is set and the player can move
              || playerVectors[1] & ~map[dest = j + playerVectors[1]] & 1 // if the x vector is set and the player can move
                ? 1 // move player
                : 0
          }[tile & 7]() // if a move should happen
            && (map[ // then set tile at new position with moving flag set (bit 3)
              map[j] = 0, // empty old position
              processed[dest] = processCount, // mark tile at new position as processed
              dest // destination tile position
            ] = tile | 8) // set bit 3 (moving)
      );
  processCount++ // increment process count
}, 99) // render and process every 99 ms
    </script>
    <script id="rawVars" type="text/plain">
    {
      iterate: 'i',
      preferably: 'r',
      seed: 'q',
      mapHeight: 'h',
      mapWidthOrTileSize: 'w',
      mapArea: 'A',
      exit: 'e',
      levelTransition: 'o',
      tiles: 'p',
      map: 'm',
      tile: 't',
      startLevel: '$',
      disableImageSmoothing: 'l',
      processCount: 'f',
      dest: 'k',
      // arguments
      prefix: 'p',
      event: 'e',
      callback: 'f',
      // predefined globals
      ctx: 'c',
      // piggybacks
      processed: 'a',
      keyDown: 'b',
      playerVectors: 'c'
    }
    </script>
  </body>
</html>
