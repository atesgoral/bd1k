<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Boulder Dash - js1k 2017</title>
    <link rel="stylesheet" href="style.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.6.0/themes/prism-okaidia.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.6.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.6.0/components/prism-javascript.min.js"></script>
    <script src="main.js"></script>
  </head>
  <body id="body">
    <header>
      <h1>Boulder Dash - js1k 2017</h1>
      <p>by <a href="http://magnetiq.com">Ates Goral</a></p>
      <p>Use arrow keys to reach the exit on the bottom right. Don't get trapped among boulders. Click on canvas to capture keyboard events.</p>
    </header>
    <main>
      <p id="error"></p>
      <p><canvas id="canvas" width="1024" height="640" tabindex="0"></canvas></p>
      <p id="bytes"></p>
      <h2>Minified</h2>
      <pre><code id="minified" class="language-javascript"></code></pre>
      <h2>Annotated</h2>
      <pre><code id="source" class="language-javascript"></code></pre>
    </main>
    <footer>
      &copy; 2017 <a href="http://magnetiq.com">Ates Goral</a>
    </footer>
    <script id="rawSrc" type="text/plain">
// predefined global variables:
// ctx - canvas 2D context

// piggybacks (on predefined global variables):
// processed - tile process markers - piggybacked on canvas element
// keyDown - key down flags - piggybacked on body element
// playerVectors - player vectors - piggybacked on canvas 2D context

// tiles
(tiles = new Image).src =
  // browsers are resilient to omitting the content type (image/png) and the trailing base-64 paddings (=)
  'data:;base64,iVBORw0KGgoAAAANSUhEUgAAACgAAAAQAgMAAAAZudU+AAAADFBMVEUAAABSUlKlKgD///8IGsOpAAAAi0lEQVQI12NgYAgN5VDiPwBkgJgLmsw3sAgAmY6Oaipv/7AGAJmBgYsWVe4XdAEyCwu7usLqgUyQWokZqemsAWBmpldUPKMDmNm1JBQmqpXlGiZ8BMyctCQwjbcAbO6MJNdQ5gNgc6XUAkPB2goLOzpCQrgfQNywSDSEQwHM7FRgmQBlKnQwOtjYAAC3bipFr0J0MQAAAABJRU5ErkJggg';

// sound effect
sfx = // initialize to 0
// processed frame counter to prevent reprocessing a moved tile
processCount = // initialize to 0
  ctx.imageSmoothingEnabled = 0; // turn off image smoothing to get crispy and chunky pixels

onkeydown = event =>
  playerVectors[
    keyDown[
      event = event.which // grab arrow key code (37: left, 38: up, 39: right, 40: down)
    ] = 1, // mark key as down
    event & 1 // vector index based on key (0: y vector, 1: x vector)
  ] = (event & 2) - 1; // set vector to -1 or 1 depending on key (y vector is inverted)

onkeyup = event =>
  keyDown[event = event.which] // if key was down
    ? playerVectors[event & 1] = // then set corresponding vector to 0
        keyDown[event] = 0 // and mark key as not down
    : 0;

mapHeight = 20; // also used as utterance rate
mapWidth = 32; // also used as tile size

mapArea = mapHeight * mapWidth;

exit = mapArea - mapWidth - 1; // inside bottom right wall

map = [
  levelTransition = 1 // level transition counter (0: run game, >0: level transition)
];

seed = 5; // PRNG (pseudo-random number generator) seed

// randomly returns true/false, with 80% preference for true
preferably = _ => (
  (seed += seed * seed | 5) // PRNG
  % // modulus to contain random values within range
  mapArea // just a large value we already have
) / mapArea < .8;

// calls given callback on every map tile
iterate = callback => {
  for (j = 0; j < mapArea;)
    callback(j, j % mapWidth, j++ / mapWidth | 0)
};

// starts a level
startLevel = _ => {
  // initialize map
  iterate(
    (j, x, y) =>
      map[j] =
        x * y // if not top or left edge
        && x < mapWidth - 1 // and not right edge
        && y < mapHeight - 1 // and not bottom edge
          // then pick a random non-wall tile
          ? preferably()
            ? preferably()
              ? 2 // dirt - 80% * 20% = 16%
              : 3 // boulder - 20% * 20% = 5%
            : 0 // empty space - 20%
          // else put a wall
          : 1 // wall
  );

  // place player on top left
  map[mapWidth + 1] = 4; // player

  // place exit
  map[exit] = 0 // empty space
};

setInterval(_ => {
  sfx = sfx && // if there's a sound effect to play
    speechSynthesis.speak(
      utterance = new SpeechSynthesisUtterance(sfx), // just speak numbers
      utterance.pitch = sfx & 2, // 0: (low) for walking & level transition, 2: (high) for boulder crash
      utterance.rate = mapHeight // spoken numbers turn into cheap sound effects when played at max rate
    );

  // render map
  iterate((j, x, y) =>
    ctx.drawImage(
      tiles, // source image
      // source tile x
      levelTransition // if level transition in progress
      && (x + y) % mapHeight <= mapHeight - levelTransition // diagonal blinds
        ? (sfx = 10) - 2 // wall tile, also play level transition sound
        : map[j] * 8, // use tile from map
      0, // source tile y
      8, // source tile width
      16, // source tile height
      x * mapWidth, // destination tile x
      y * mapWidth, // destination tile y
      mapWidth, // destination tile width
      mapWidth // destination tile height
    )
  );

  levelTransition // if in the process of level transition
    ? --levelTransition || // then decrement counter
      startLevel() // start next level if counter has reached 0
    : map[exit] // else if exit is occupied (by player)
      ? levelTransition = mapHeight // then start level transition
      : iterate( // else process map
        j =>
          processed[j] != processCount && // tile hasn't been already processed in this frame (might have been moved into this position)
          (t = map[j]) > 2 && // if tile boulder or player
          { // tile handlers
            3: _ => // boulder
              !map[k = j + mapWidth] // if beneath the boulder is empty
                ? map[k + mapWidth]
                  ? sfx = 2 // play boulder crash sound and ...
                  : 1 // move boulder down
                : map[j + mapWidth] == 3 // else if resting on another boulder
                  ? map[k = j - 1] + map[j + mapWidth - 1] < 1 // else if can slide left
                    ? 1 // move boulder left
                    : map[k = j + 1] + map[j + mapWidth + 1] < 1 // else if can slide right
                      ? 1 // move boulder right
                      : 0
                  : 0,
            4: _ => // player
              playerVectors[0] & ~map[k = j + playerVectors[0] * -mapWidth] & 1 // if the y vector is set and the player can move
              || playerVectors[1] & ~map[k = j + playerVectors[1]] & 1 // if the x vector is set and the player can move
                ? sfx = sfx || 1 // move player and play walking sound
                : 0
          }[t]() && // invoke tile handler and if a move should happen
            (map[
              map[j] = 0, // empty old position
              processed[k] = processCount, // mark tile at new position as processed
              k // new tile position
            ] = t), // set tile at new position
        processCount++ // increment process count
      )
}, 99) // render and process every 99 ms
    </script>
    <script id="rawVars" type="text/plain">
    {
      iterate: 'i',
      preferably: 'r',
      seed: 'q',
      mapHeight: 'h',
      mapWidth: 'w',
      mapArea: 'A',
      exit: 'e',
      levelTransition: 'o',
      tiles: 'p',
      map: 'm',
      startLevel: '$',
      disableImageSmoothing: 'l',
      processCount: 'f',
      sfx: 'g',
      utterance: 'u',
      // arguments
      prefix: 'p',
      event: 'e',
      callback: 'f',
      // predefined globals
      ctx: 'c',
      // piggybacks
      processed: 'a',
      keyDown: 'b',
      playerVectors: 'c'
    }
    </script>
  </body>
</html>
