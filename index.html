<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Boulder Dash</title>
    <link rel="stylesheet" href="style.css">
  </head>
  <body id="body">
    <div id="error"></div>
    <canvas id="canvas" width="1024" height="640"></canvas>
    <div id="bytes"></div>
    <textarea id="minified" rows="12"></textarea>
    <script>
      const a = canvas;
      const b = body;
      const c = a.getContext('2d');
      const d = document;

      a.width = a.offsetWidth;
      a.height = a.offsetHeight;
    </script>
    <script id="source" type="text/annotated">
// Tiles
(p = new Image).src = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACgAAAAQAgMAAAAZudU+AAAADFBMVEUAAABfX1/QQAD///+L6qNxAAAAi0lEQVQI12NgYAgN5VDiPwBkgJgLmsw3sAgAmY6Oaipv/7AGAJmBgYsWVe4XdAEyCwu7usLqgUyQWokZqemsAWBmpldUPKMDmNm1JBQmqpXlGiZ8BMyctCQwjbcAbO6MJNdQ5gNgc6XUAkPB2goLOzpCQrgfQNywSDSEQwHM7FRgmQBlKnQwOtjYAAC3bipFr0J0MQAAAABJRU5ErkJggg';

// Turn off image smoothing for enlarged tiles on Chrome & Firefox
l = p => c[p + 'mageSmoothingEnabled'] = 0;

f = l('i'), l('mozI'); // f is the processed frame counter to prevent reprocessing a moved tile

onkeydown = e => c[b[e = e.which] = 1, e & 1] = (e & 2) - 1;
onkeyup = e => b[e = e.which] && (c[e & 1] = a[e] = 0);

h = 20; // Map height
w = 32; // Map width and tile size
A = h * w; // Map area
e = A - w - 1; // Exit location

m = [ // Map
  o = 1 // Level restart countdown. 0 to run game, >0 to stop game & render level transition animation
];

q = 5; // PRNG seed

r = _ => (
  (q += q * q | 5) // PRNG (pseudo-random number generator)
  %
  A
) / A < .8;

v = (j, t) => m[a[j] = f, j] = t;

i = f => {
  for (j = 0; j < A; j++)
    f(j, j % w, 0 | j / w)
};

$ = _ => {
  i((j, x, y) => m[j] = x * y && x < w - 1 && y < h - 1 ? r() ? r() ? 2 : 3 : 0 : 1);
  m[w + 1] = 4;
  m[e] = 0
};

setInterval( _ => {
  i((j, x, y) => c.drawImage(p, o && (x + y) % h <= h - o ? 8 : m[j] * 8, 0, 8, 16, x * w, y * w, w, w));

  o ? --o || $() : m[e] ? (o = h) : i(j => a[j] != f && (t = m[j]) > 2 && {
    3: _ => !m[j+w]&&(v(j+w,3),m[j]=0,1)||(m[j+w]==3)&&((m[j-1]+m[j+w-1]<1)&&(v(j-1,3),v(j,0),1)||(m[j+1]+m[j+w+1]<1)&&(v(j+1,3),v(j,0))),
    4: _ => (c[0]&&~m[k=j+c[0]*-w]&1||c[1]&&~m[k=j+c[1]]&1)&&v(k,4,m[j]=0)
  }[t](), f++)
}, 99)
    </script>
    <script>
      const src = source.innerHTML;
      // Poor man's minifier
      const min = src
        .replace(/\s+\/\/.+$/gm, '') // Trim line comments
        .replace(/[\s\n]+(?!\w)/gm, '') // Trim all whitespace that are not followed by word character
        .replace(/(\W)[\s\n]+/gm, '$1'); // Trim all whitespace that follow a non-word character

      bytes.innerHTML = min.length;
      minified.value = min;

      try {
        eval(min);
      } catch (e) {
        error.innerHTML = e.message;
      }
    </script>
  </body>
</html>
