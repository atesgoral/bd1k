<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Boulder Dash</title>
    <link rel="stylesheet" href="style.css">
  </head>
  <body id="body">
    <div id="error"></div>
    <canvas id="canvas" width="1024" height="640"></canvas>
    <div id="bytes"></div>
    <textarea id="minified" rows="12"></textarea>
    <script>
      const a = canvas;
      const b = body;
      const c = a.getContext('2d');
      const d = document;

      a.width = a.offsetWidth;
      a.height = a.offsetHeight;
    </script>
    <script id="source" type="text/annotated">
// predefined global variables:
// ctx - canvas 2D context

// tiles
(tiles = new Image).src = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACgAAAAQAgMAAAAZudU+AAAADFBMVEUAAABfX1/QQAD///+L6qNxAAAAi0lEQVQI12NgYAgN5VDiPwBkgJgLmsw3sAgAmY6Oaipv/7AGAJmBgYsWVe4XdAEyCwu7usLqgUyQWokZqemsAWBmpldUPKMDmNm1JBQmqpXlGiZ8BMyctCQwjbcAbO6MJNdQ5gNgc6XUAkPB2goLOzpCQrgfQNywSDSEQwHM7FRgmQBlKnQwOtjYAAC3bipFr0J0MQAAAABJRU5ErkJggg';

// turn off image smoothing for image enlarging on Chrome & Firefox to get crispy and chunky pixels
disableImageSmoothing = p => ctx[p + 'mageSmoothingEnabled'] = 0;

processCount = // processed frame counter to prevent reprocessing a moved tile
  disableImageSmoothing('i'),
  disableImageSmoothing('mozI');

onkeydown = e =>
  playerVectors[b[e = e.which] = 1, e & 1] = (e & 2) - 1;

onkeyup = e =>
  b[e = e.which] &&
    (playerVectors[e & 1] = a[e] = 0);

mapHeight = 20;
mapWidthOrTileSize = 32;

mapArea = mapHeight * mapWidthOrTileSize;

exit = mapArea - mapWidthOrTileSize - 1;

map = [
  levelTransition = 1 // Level transition counter. 0 to run game, >0 to stop game & render level transition animation
];

seed = 5; // PRNG seed

preferably = _ => (
  (seed += seed * seed | 5) // PRNG (pseudo-random number generator)
  %
  mapArea
) / mapArea < .8;

set = (j, t) =>
  map[
    a[j] = processCount,
    j
  ] = t;

iterate = f => {
  for (j = 0; j < mapArea; j++)
    f(j, j % mapWidthOrTileSize, j / mapWidthOrTileSize | 0)
};

restart = _ => {
  iterate(
    (j, x, y) =>
      map[j] = x * y && x < mapWidthOrTileSize - 1 && y < mapHeight - 1
        ? preferably()
          ? preferably()
            ? 2
            : 3
          : 0
        : 1
  );

  map[mapWidthOrTileSize + 1] = 4;
  map[exit] = 0
};

setInterval( _ => {
  // Render tiles
  iterate((j, x, y) =>
    ctx.drawImage(
      tiles,
      levelTransition && (x + y) % mapHeight <= mapHeight - levelTransition
        ? 8
        : map[j] * 8,
      0, // source tile y
      8, // source tile width
      16, // source tile height
      x * mapWidthOrTileSize, // destination tile x
      y * mapWidthOrTileSize, // destination tile y
      mapWidthOrTileSize, // destination tile width
      mapWidthOrTileSize // destination tile height
    )
  );

  levelTransition // if in the process of level transition
    ? --levelTransition || // then decrement counter
      restart() // start next level if counter has reached 0
    : map[exit] // else if exit is occupied (by player)
      ? (levelTransition = mapHeight) // then start level transition
      : iterate( // else process map
        j =>
          a[j] != processCount && // tile hasn't been already processed in this frame (might have been moved into this position)
          (t = map[j]) > 2 &&
          {
            3: _ =>
              !map[j + mapWidthOrTileSize] && (
                set(j + mapWidthOrTileSize, 3), map[j] = 0, 1 // Move boulder down, return truthy
              ) ||
                (map[j + mapWidthOrTileSize] == 3) &&
                ((map[j - 1] + map[j + mapWidthOrTileSize - 1] < 1) &&
                  (set(j - 1, 3), set(j, 0), 1) || (map[j + 1] + map[j + mapWidthOrTileSize + 1] < 1) && (set(j + 1, 3), set(j, 0))),
            4: _ =>
              (playerVectors[0] && ~map[k = j + playerVectors[0] * -mapWidthOrTileSize] & 1 || playerVectors[1] && ~map[k = j + playerVectors[1]] & 1) && set(k, 4, map[j] = 0)
          }[t](),
        processCount++ // increment process count
      )
}, 99)
    </script>
    <script>
      const src = source.innerHTML;
      // Poor man's minifier
      const min = src
        .replace(/\s+\/\/.+$/gm, '') // Trim line comments
        .replace(/[\s\n]+(?!\w)/gm, '') // Trim all whitespace that are not followed by word character
        .replace(/(\W)[\s\n]+/gm, '$1') // Trim all whitespace that follow a non-word character
        .replace(/(\w+)/gm, (s, name) => { // Shorten variables
          return {
            iterate: 'i',
            preferably: 'r',
            seed: 'q',
            mapHeight: 'h',
            mapWidthOrTileSize: 'w',
            mapArea: 'A',
            exit: 'e',
            levelTransition: 'o',
            tiles: 'p',
            map: 'm',
            set: 'v',
            restart: '$',
            ctx: 'c',
            playerVectors: 'c',
            disableImageSmoothing: 'l',
            processCount: 'f'
          }[name] || name;
        });

      bytes.innerHTML = min.length;
      minified.value = min;

      try {
        eval(min);
      } catch (e) {
        error.innerHTML = e.message;
      }
    </script>
  </body>
</html>
